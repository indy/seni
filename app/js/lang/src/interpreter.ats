const TRUE_STRING = '#t';
const FALSE_STRING = '#f';

export function evaluate(env, expr) {

  // todo: may need something like:
  if (typeof expr === 'number') {
    return expr;
  }
  if (typeof expr === 'string') {
    if(expr === TRUE_STRING || expr === FALSE_STRING) {
      return expr;
    }
    return env.lookup(expr);
  }
  return funApplication(env, expr);
}

function funApplication(env, listExpr) {

  const fun = evaluate(env, listExpr[0]);

  // special forms that manipulate the listExpr
  if(isSpecialForm(listExpr)) {
    return fun(env, listExpr);
  }

  // classic functions that don't require named arguments
  if(isClassicFunction(listExpr)) {
    const args = listExpr.slice(1).map(n => evaluate(env, n));
    return fun(args);
  }

  // normal functions that require named arguments
  let args = {};
  if(listExpr.length > 1) {
    const argObj = listExpr[1];
    for(let k in argObj) {
      args[k] = evaluate(env, argObj[k]);
    }
  }
  return fun(args);
}

function isSpecialForm(listExpr) : boolean {
  const node = listExpr[0];
  return specialForms[node] !== undefined;
}

function isClassicFunction(listExpr) : boolean {
  const node = listExpr[0];
  return classicFunctions[node] !== undefined;
}

function addBindings(env, exprs) {

  const addBinding = function(name, value) {
    const v = evaluate(env, value);
    if(name.constructor === Array) {
      // destructure
      // todo: error check if size of name array !== size of v
      name.forEach((n, i) => env.add(n, v[i]));
    } else {
      env.add(name, v);
    }
  }

  exprs.forEach(([name, value]) => addBinding(name, value));

  return env;
}

export var specialForms = {
  'if': (env, expr) => {
    const conditional = evaluate(env, expr[1]);
    // todo: only a value of #t is truthy, change this so that
    // any non-zero, non-falsy value is truthy
    if(conditional === TRUE_STRING) {
      return evaluate(env, expr[2]);
    } else {
      if(expr.length == 4) {
        return evaluate(env, expr[3]);
      }
    }
  },
  'quote': (env, expr) => {
    return expr[1];       
  },
  'define': (env, expr) => {
    // (define foo 12)
    const name = expr[1];
    const val = expr[2];
    env.add(name, evaluate(env, val));
  },
  'set!': (env, expr) => {
    // (set! foo 42)
    const name = expr[1];
    const val = expr[2];
    env.mutate(name, evaluate(env, val));
  },
  'begin': (env, expr) => {
    // (begin (f1 1) (f2 3) (f3 5))
    return expr.slice(1).reduce((a, b) => evaluate(env, b), null);
  },
  'let': (env, expr) => {
    // (let ((a 12) (b 24)) (+ a b foo))
    return evaluate(addBindings(env.newScope(), expr[1]), expr[2]);
  },
  'lambda': (env, expr) => {
    // (lambda (x: 0 y: 0) (+ x y))
    return function(args) {
      const newEnv = env.newScope();

      const defaultArgValues = expr[1];
      for(let k in defaultArgValues) {
        if(args[k] !== undefined) {
          newEnv.add(k, args[k]);
        } else {
          newEnv.add(k, defaultArgValues[k]);
        }
      }
      return evaluate(newEnv, expr[2]);
    };
  },
  'log': (env, expr) => { console.log(evaluate(env, expr[1]))},
  'loop': (env, expr) => {
    // (loop (a from: 1 to: 30 step: 2) (+ a a))
    const [varName, varParameters] = expr[1];
    for(let k in varParameters) {
      varParameters[k] = evaluate(env, varParameters[k]);
    }
    return loopingFn(env.newScope(), expr.slice(2), varName, varParameters);
  }
}

function loopingFn(env, expr, varName, {from = 0,
                                        to = 10,
                                        until = undefined,
                                        step = 1}) {
  // todo: 'to' should be <=, and 'until' should be '<'

  if(step === 0) {
    console.log("step size of 0 given");
    return;
  }

  var res;

  if(until !== undefined) {
    for(let i=from;i<=until;i+=step) {
      env.add(varName, i);
      res = expr.reduce((a, b) => evaluate(env, b), null);
    }
  } else {
    for(let i=from;i<to;i+=step) {
      env.add(varName, i);
      res = expr.reduce((a, b) => evaluate(env, b), null);
    }
  }

  return res;
}

// todo: classic functions are here because it wouldn't make sense to use named parameters for these functions.
// perhaps there should by a syntax like prefixing with @ to indicate that the function takes a variable number of non-named paramters?
// could get rid of the concept of classic functions and allow the user to create @ functions at the expense of having code like: (@+ 4 3 7 4) rather than (+ 4 3 7 4)

export var classicFunctions = {
  '+': (args) => args.reduce((a, b) => a + b, 0),

  '*': (args) => args.reduce((a, b) => a * b, 1),
  
  '-': (args) => args.length === 1 ? -args[0] : args.reduce((a, b) => a - b),

  '/': (args) => args.reduce((a, b) => a / b),
  
  '=': (args) => {
    const first = args[0];
    const res = args.slice(1).every(a => a === first);
    return res ? TRUE_STRING : FALSE_STRING;
  },
  '<': (args) => {
    let prev = args[0];
    for(let i = 1; i < args.length; i++) {
      const current = args[i];
      if(!(current < prev)) {
        return FALSE_STRING
      }
      prev = current;
    }
    return TRUE_STRING;
  },
  '>': (args) => {
    let prev = args[0];
    for(let i = 1; i < args.length; i++) {
      const current = args[i];
      if(!(current > prev)) {
        return FALSE_STRING;
      }
      prev = current;
    }
    return TRUE_STRING;
  },
  'list' : (args) => args,
  'pair' : (args) => {
    let res = [];
    for(let i=0;i<args.length;i+=2) {
      res.push([args[i], args[i+1]]);
    }
    return res;
  }
}



