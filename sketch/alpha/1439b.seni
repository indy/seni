
(define numSquaresToRender 13)
(define gapSize 30)

(define numSquares (+ 2 numSquaresToRender))

(define numGaps (+ numSquares 1))
(define squareSize (/ (- 1000 (* gapSize numGaps)) numSquares))


(loop (y from: 1 to: (- numSquares 1))
	(loop (x from: 1 to: (- numSquares 1))
          (let ((xPos (mapToPosition at: x))
                (yPos (mapToPosition at: y)))
            (accumulated-rect x: xPos
                              y: yPos
                              passes: 20
                              volatility: (/ (math/distance2D aX: 500 
                                                           	  aY: 500
                                                              bX: xPos
                                                              bY: yPos) 250)
                              seed: (+ x (* y numSquares))
                              width: squareSize 
                              height: squareSize
                              colour: (col/rgb r: 1.0 g: 0.0 b: 0.4 a: 1.0)))))

(define (mapToPosition at: 0)
  (+ (* (+ gapSize squareSize) at) (/ squareSize 2) gapSize))

(define (accumulated-rect x: 0
                          y: 0
                          width: 10
                          height: 10
                          colour: (col/rgb r: 0.0 g: 1.0 b: 0.0 a: 0.5)
                          volatility: 0
                          passes: 1
                          seed: "asdf")
  (let ((halfWidth (/ width 2))
        (halfHeight (/ height 2))
        (alpha (col/getAlpha colour: colour))
        (passColour (col/setAlpha colour: colour alpha: (/ alpha passes)))
        (rng (rng/signed seed: seed)))
    (onMatrixStack
     (translate x: x y: y)
     (loop (i to: passes)
           (let (((rr xr yr) (take num: 3 from: rng)))
             (onMatrixStack
              (rotate angle: (* rr 0.02 volatility))
              (rect x: (* xr 5 volatility)
                    y: (* yr 5 volatility)
                    width: width
                    height: height
                    colour: passColour)))))))

(define (v x: 0 y: 0 z: 0 scale: 1)
  (+ y (* scale (perlin/unsigned x: x y: y z: z))))

(define (wash variation: 200
              lineWidth: 70
              lineSegments: 5
              colour: (col/rgb r: 0.627 g: 0.627 b: 0.627 a: 0.4)
              seed: 272)
  (loop (h from: -20 to: 1020 step: 20)
        (bezier tessellation: lineSegments
                lineWidth: lineWidth
                coords: (pair
                         0 (v x: 0.10 y: h z: seed scale: variation)
                         333 (v x: 333.33 y: h z: seed scale: variation)
                         666 (v x: 666.66 y: h z: seed scale: variation)
                         1000 (v x: 1000.10 y: h z: seed scale: variation))
                colour: colour)
        (bezier tessellation: lineSegments
                lineWidth: lineWidth
                coords: (pair
                         (v x: 0.10 y: h z: seed scale: variation) 0
                         (v x: 333.33 y: h z: seed scale: variation) 333
                         (v x: 666.66 y: h z: seed scale: variation) 666
                         (v x: 1000.10 y: h z: seed scale: variation) 1000)
                colour: colour)))
