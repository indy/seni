* TODO [0/10]
  1. [ ] colour presets
  2. [ ] play around with stroked-bezier-rect
  3. [ ] test new setup/teardown code
  4. [ ] cleanup memory of parser
  5. [ ] structs for compile, runtim, performance info
  6. [ ] seni_env
  7. [ ] 'in' paramaeter for loop ?
  8. [ ] remove hsv colour space? - would this get rid of the illegal state?
  9. [ ] should ADD, SUB, MUL, DIV, NEG be updated to take into account VAR_2D?
  10. [ ] look at colour palettes in https://www.npmjs.com/package/nice-color-palettes

* updating scripts [8/57]
  1. [X] 14ef-blur-grid.seni
  2. [X] 14eg-marker-grid.seni
  3. [X] 14eh-chaotic-grid.seni
  4. [X] 14fh-rothko-1.seni
  5. [X] 151c-flower.seni - bezier-bulging
  6. [X] 1531-four-squares.seni
  7. [X] 154c-stroked-bezier.seni
  8. [X] 154h-rothko-2.seni -- TODO: THIS IS SLOW
  9. [ ] 1556-biomorphs.seni - repeat/symmetry-vertical - takes a 'draw' argument
  10. [ ] 155b-spiral-derived.seni - path/circle
  11. [ ] 155j-chaotic-grid-2.seni - focal/point
  12. [ ] 155j-chaotic-grid-3.seni
  13. [ ] 1560-path.seni - make a function ???
  14. [ ] 1565-hex-grid.seni
  15. [ ] 156h-tri-grid.seni
  16. [ ] 157e-tile-shadow.seni - col/procedural-fn
  17. [ ] 1580-quilt.seni
  18. [ ] 1585-seeds.seni
  19. [ ] 15fe-rotate-mirror.seni - poly, repeat/rotate-mirrored
  20. [ ] 15h3-polychrome.seni
  21. [ ] 15h3-rotate-mirror-2.seni
  22. [ ] 15h3-tri-grid.seni
  23. [ ] 15h4-chromatic-layers-1.seni
  24. [ ] 15h4-chromatic-layers-2.seni
  25. [ ] 15h4-chromatic-layers-3.seni
  26. [ ] 15h4-mirror-layers.seni
  27. [ ] 15h4-rotate-mirror.seni
  28. [ ] 15he-cos-1.seni
  29. [ ] 15he-cos-2.seni
  30. [ ] 15he-cos-3.seni
  31. [ ] 15he-mirror-layers.seni
  32. [ ] 15he-rotate-mirror.seni
  33. [ ] 160c-schotter.seni
  34. [ ] 161g-grid-flow.seni
  35. [ ] 161j-trump.seni
  36. [ ] 1626-embers.seni
  37. [ ] 1626-orchid.seni
  38. [ ] 162e-alien.seni
  39. [ ] 162e-mask.seni
  40. [ ] 162e-slice.seni
  41. [ ] 162e-star.seni
  42. [ ] 162e-x.seni
  43. [ ] 1632-star.seni
  44. [ ] 1633-dune.seni
  45. [ ] 1633-orchid.seni
  46. [ ] 1633-petal.seni
  47. [ ] 1634-cryst.seni
  48. [ ] 1638-night.seni
  49. [ ] 163a-scale-green.seni
  50. [ ] 1642-book-stack.seni
  51. [ ] 1642-stacks.seni
  52. [ ] 1643-hyp.seni
  53. [ ] 1643-paren.seni
  54. [ ] 1643-rose.seni
  55. [ ] 1643-thorn.seni
  56. [ ] 1648-chalk-boxes.seni
  57. [ ] 1669-zero.seni

* seni_env

  standard universal bindings (done once, immutable, applied to all compiled/executed programs)
  e.g. the standard api functions in seni_env

  standard per-program bindings (done at program start, equivalent to a set of known global variables)
  e.g. global bindings like canvas/width which require a call to add_global_mapping.

  per-program bindings (parse through the program)



* seni_vm
  four types of command in the VM:
  1. Arithmetic: perform arithmetic and logical operations on the stack
  2. Memory access: transfer data between the stack and virtual memory
  3. Program flow: conditional and unconditional branching operations
  4. Function calling: call functions and return from them

(+ 7 8)

push constant 7
push constant 8
add


(- 10 2)

push constant 10
push constant 2
sub

B + C - D  ==> 

B C + D -  (post fix)
(- (+ B C) D) (pre fix)
traverse ast: lhs, rhs, op


push val B,
push val C, 
add,
push val D,
sub. 


* loop usage
from to
to
from to increment
from upto
from upto steps

* bytecode vm design for guile
  https://www.gnu.org/software/guile/manual/html_node/Why-a-VM_003f.html#Why-a-VM_003f

  bytecode interpreter written in C



Compiled code is run by a virtual machine (VM). Each thread has its own VM. The virtual machine executes the sequence of instructions in a procedure.

Each VM instruction starts by indicating which operation it is, and then follows by encoding its source and destination operands. Each procedure declares that it has some number of local variables, including the function arguments. These local variables form the available operands of the procedure, and are accessed by index.

The local variables for a procedure are stored on a stack. Calling a procedure typically enlarges the stack, and returning from a procedure shrinks it. Stack memory is exclusive to the virtual machine that owns it.

In addition to their stacks, virtual machines also have access to the global memory (modules, global bindings, etc) that is shared among other parts of Guile, including other VMs.

The registers that a VM has are as follows:

ip - Instruction pointer
sp - Stack pointer
fp - Frame pointer
In other architectures, the instruction pointer is sometimes called the "program counter" (pc). This set of registers is pretty typical for virtual machines; their exact meanings in the context of Guile's VM are described in the next section.



  

* simple bytecode vm
  https://www.youtube.com/watch?v=8k5h-A7JaaE&t=6s&index=36&list=WL
  1:03:39

  a lot of the enums start at 128

  opcode_t
  push add sub mul div mod neg ret

  char bytecode_buffer[1024];
  char *bytecode = bytecode_buffer;

  emit(uint8 byte) {
    *bytecode++ = byte;
  }
  emit4(uint32 data) {
    *(uint32 *)bytecode = data;
    bytecode += 4;
  }

  ---------------------------------------------------------------------------

  bytecode interpreter

  char *ip;
  int execute_stack[1024];
  int *sp = execute_stack

  void execute() {
    for(;;) {
      int op = *ip++;
      switch (op) {
      PUSH:
        *sp++ = *(uint32 *)ip;
        ip += 4;
      ADD:
        sp[-2] += sp[-1];
        sp--;
        break;
        ....
      RET:
        // return whats on top of the stack
        return sp[-1];
      }
 
    }
  }


  test code:

  emit(PUSH)
  emit(1)
  emit(PUSH)
  emit(2)
  emit(ADD)
  emit(RET)


  char emit_buffer[1024];
  emit_pointer = emit_buffer;

  int frame[1024];
  int stack[1024];

  ip = emit_buffer;
  fp = frame;
  sp = stack

  int val = execute();




* vm links
  http://bartoszsypytkowski.com/simple-virtual-machine/

  https://github.com/munificent/wren
  http://wren.io/getting-started.html
  http://gameprogrammingpatterns.com/bytecode.html
  https://github.com/skx/simple.vm/tree/master/examples
  http://www.jucs.org/jucs_11_7/the_implementation_of_lua/jucs_11_7_1159_1176_defigueiredo.html
  http://smalltalk.gnu.org/files/vmspec.pdf
  http://stackoverflow.com/questions/20313122/generating-register-based-bytecode-from-an-abstract-syntax-tree
  http://hhvm.com/blog/6323/the-journey-of-a-thousand-bytecodes
  https://www.reddit.com/r/learnprogramming/comments/w6i0p/bytecode_execution_vs_ast_walking_speed/

* wren vm notes
  Unlike expressions, statements do not leave a value on the stack.


  wren_vm.c:
  initvm
    wrenconfiguration structure
    vm = wrenNewVM(configuration)
      symbol table init
      wrenInitializeCore                <<<-- wren_core.c
        define root Object class
        PRIMITIVE macro ?
        all the core primitives (keywords in seni?) have now been defined

  WrenInterpretResult result = wrenInterpret(vm, source); <<<-- vm.c
    WrenVM is passed around
    creates a 'main' module (in a tempRoot), creates a 'fiber' and runs interpreter with that fiber
      Value ???
      wrenStringFormat returns a large number
  is interpreter called twice? first for core module then for the user specified main module?
  loadModule calls wrenCompile
  
  wrenCompile <<<<-- wren_compiler.c
    lexer parser etc
    

  static WrenInterpretResult runInterpreter(WrenVM* vm, register ObjFiber* fiber) <<<<<-- wren_vm.c

  definition(compiler)
  statement(compiler)
  expression(compiler)
  literal(compiler, canAssign)
  emitConstant

  WREN_NAN_TAGGING - if not defined this makes debugging easier as Value has a type and num structure

** wren analysis scratch notes
 >	wren_d.exe!emitOp(sCompiler * compiler, Code instruction) Line 1171	C
 	 wren_d.exe!emitShortArg(sCompiler * compiler, Code instruction, int arg) Line 1200	C
 	 wren_d.exe!emitConstant(sCompiler * compiler, unsigned __int64 value) Line 1221	C
 	 wren_d.exe!literal(sCompiler * compiler, bool canAssign) Line 2267	C
 	 wren_d.exe!parsePrecedence(sCompiler * compiler, Precedence precedence) Line 2680	C
 	 wren_d.exe!infixOp(sCompiler * compiler, bool canAssign) Line 2434	C
 	 wren_d.exe!parsePrecedence(sCompiler * compiler, Precedence precedence) Line 2686	C
 	 wren_d.exe!expression(sCompiler * compiler) Line 2694	C
 	 wren_d.exe!forStatement(sCompiler * compiler) Line 2905	C
 	 wren_d.exe!statement(sCompiler * compiler) Line 2992	C
 	 wren_d.exe!definition(sCompiler * compiler) Line 3421	C
 	 wren_d.exe!wrenCompile(WrenVM * vm, ObjModule * module, const char * source, bool isExpression, bool printErrors) Line 3468	C
 	 wren_d.exe!loadModule(WrenVM * vm, unsigned __int64 name, const char * source) Line 490	C
 	 wren_d.exe!wrenInterpretInModule(WrenVM * vm, const char * module, const char * source) Line 1328	C
 	 wren_d.exe!wrenInterpret(WrenVM * vm, const char * source) Line 1315	C
 	 wren_d.exe!runFile(const char * path) Line 232	C






   when compiling user code set a breakpoint on emitOp wren_compiler.c 1170

   System.print("hello from isg")
   for (i in 1..10) System.print("Counting up %(i)")

   instruction	CODE_LOAD_MODULE_VAR (17)	Code
   instruction	CODE_CONSTANT (0)	Code
	 instruction	CODE_CALL_1 (25)	Code
	 instruction	CODE_POP (23)	Code
	 instruction	CODE_CONSTANT (0)	Code
	 instruction	CODE_CONSTANT (0)	Code
	 instruction	CODE_CALL_1 (25)	Code
	 instruction	CODE_NULL (1)	Code
	 instruction	CODE_LOAD_LOCAL_0 (4)	Code
	 instruction	CODE_LOAD_LOCAL_1 (5)	Code
	 instruction	CODE_CALL_1 (25)	Code
	 instruction	CODE_STORE_LOCAL (14)	Code
	 instruction	CODE_JUMP_IF (60)	Code
	 instruction	CODE_LOAD_LOCAL_0 (4)	Code
	 instruction	CODE_LOAD_LOCAL_1 (5)	Code
	 instruction	CODE_CALL_1 (25)	Code
	 instruction	CODE_LOAD_MODULE_VAR (17)	Code
	 instruction	CODE_LOAD_MODULE_VAR (17)	Code
	 instruction	CODE_CALL_0 (24)	Code
	 instruction	CODE_CONSTANT (0)	Code
	 instruction	CODE_CALL_1 (25)	Code
	 instruction	CODE_LOAD_LOCAL_2 (6)	Code
	 instruction	CODE_CALL_1 (25)	Code
	 instruction	CODE_CONSTANT (0)	Code
	 instruction	CODE_CALL_1 (25)	Code
	 instruction	CODE_CALL_0 (24)	Code
	 instruction	CODE_CALL_1 (25)	Code
	 instruction	CODE_POP (23)	Code
	 instruction	CODE_LOOP (59)	Code



** wren build shenanigans

 Build Events -> Command Line had the following pasted in:

 python ../../libuv.py download
 python ../../libuv.py build -32

* looking up arguments during bytecode execution

given:

(fn (something alpha: 10 beta: 20)
    (+ alpha beta))

assuming that the wlut values are:

| something | 42 |
| alpha     | 53 |
| beta      | 67 |

the MEM_SEG_ARGUMENT memory will be:

| 0 | 53 |
| 1 | 10 |
| 2 | 67 |
| 3 | 20 |

the fn_info->argument_offsets array would be:

| 0 | 53 |
| 1 | 67 |

then:
// finding argument location of 'beta':

index = get_argument_mapping(fn_info, 67); // returns 1
index_into_arguments_memory = (index * 2) + 1

--------------------------------------------------------------------------------

invoking a function would involve:
1. setting up the ARG memory with the default arguments given in the function signature (CALL_PREP ???)
2. overwriting particular values with those from the invocation (RET followed by PUSH/POP to change arg mem)
3. actually calling the function (CALL straight into function body, followed by RET)

fn_info would then have 2 addresses - 1 for setting up args, the other for the body

* bytecode sequence when calling functions


  (fn (adder a: 9 b: 8) (+ a b)) (adder a: 5 b: 3)

  0       JUMP    +14
  1       PUSH    CONST   1
  2       POP     ARG     0
  3       PUSH    CONST   9
  4       POP     ARG     1
  5       PUSH    CONST   2
  6       POP     ARG     2
  7       PUSH    CONST   8
  8       POP     ARG     3
  9       RET_0
  10      PUSH    ARG     1
  11      PUSH    ARG     3
  12      ADD
  13      RET
  14      CALL    1       2
  15      PUSH    CONST   5
  16      POP     ARG     1
  17      PUSH    CONST   3
  18      POP     ARG     3
  19      CALL_0 10      2
  20      STOP


  calling a function involves the following sequence being executed:

  CALL      Pushes a frame onto the stack and jumps to the given ip
  RET_0     Returns to the ip stored in the frame pointer on the stack without popping the frame
  CALL_0    Jumps to the given ip without pushing a new frame (it does modify the ip on the frame 
            so that execution will return to the correct location at the next RET)
  RET       Returns to the ip stored in the frame pointer on the stack and pops the current frame


  This way, invoking a function results in the following:
  1. There are some empty pushes onto the stack in order to make room for all the named arguments
  2. A frame is pushed onto the stack
  3. The empty pushes from (1) are filled in with default values
  4. RET_0 moves the ip back to the calling code which can then override the default values
  5. CALL_0 moves the ip into the body of the called function, retaining the current frame
  6. The body is executed
  7. RET pops the frame and copies the last value from the function onto the current stack

  a flaw in this scheme is that LOCAL will now reference the new frame created 
  after CALL and nothing will be found e.g.

  17      CALL    1       1    <<<< - creates a new frame
  18      PUSH    LOCAL   0    <<<< - so now 'LOCAL' doesn't reference what you think it should
  19      DEC_RC  ARG     1
  20      POP     ARG     1
  21      INC_RC  ARG     1
  22      CALL_0  6       1



  another thing to note are the DEC_RC and INC_RC opcodes. These ensure that default arguments 
  which are vectors and will be overidden by the calling code will have their reference counts 
  correctly altered

  17      CALL    1       1    
  18      PUSH    LOCAL   0    
  19      DEC_RC  ARG     1    <<<< - decrement the reference count for the default argument
  20      POP     ARG     1
  21      INC_RC  ARG     1    <<<< - increment the caller supplied argument
  22      CALL_0  6       1
  

* frame structure


  ^^^ stack grows upwards
  ------------- <- sp of new frame
  locals (10)
  num_args
  IP
  FP
  args (n * 2)
  ------------- <- sp of previous frame
  ...
  ...

  after a function returns, the frame is popped and the sp has increased by one as it holds the return value from the function


* benchmarking

| hash    | date             | opcodes | heap count | water mark | packets | bytecode time | total time |
|---------+------------------+---------+------------+------------+---------+---------------+------------|
| 24318cb | <2017-06-29 Thu> |  743718 |     122593 |         25 |      11 | 20ms          | 21ms       |
| 46e6b1a | <2017-06-30 Fri> |  705086 |      64645 |         14 |      11 | 18ms          | 19ms       |
   
** script
 (define 
   num-squares-to-render 15
   gap-size 30
   num-squares (+ 2 num-squares-to-render)
   num-gaps (+ num-squares 1)
   square-size (/ (- canvas/width (* gap-size num-gaps)) num-squares))

 (wash variation: 40
       line-width: 25
       line-segments: 5
       colour: (col/rgb r: 1.0 g: 1.0 b: 0.9))

 (loop (y from: 1 to: (- num-squares 1))
   (loop (x from: 1 to: (- num-squares 1))
     (define 
       x-pos (map-to-position at: x)
       y-pos (map-to-position at: y))
     (stroked-bezier-rect position: [x-pos y-pos]
                          colour-volatility: 20
                          volatility: (/ (math/distance vec1: [(/ canvas/width 2)
                                                               (/ canvas/height 2)]
                                                        vec2: [x-pos y-pos])
                                         100)
                          seed: (+ x (* y num-squares))
                          width: square-size 
                          height: square-size
                          colour: (col/rgb r: 1.0
                                           g: 0.0
                                           b: 0.4
                                           alpha: 1.0))))

 (fn (map-to-position at: 0)
     (+ (* (+ gap-size square-size) at) (/ square-size 2) gap-size))

 (fn (stroked-bezier-rect position: [0 0]
                          width: 10
                          height: 10
                          colour: (col/rgb r: 0.0 g: 1.0 b: 0.0 alpha: 0.5)
                          colour-volatility: 0
                          volatility: 0
                          overlap: 3
                          iterations: 10
                          seed: 343)
     (define 
       [x y] position
       third-width (/ width 3)
       third-height (/ height 3)
       vol volatility

       start-x (- x (/ width 2))
       start-y (- y (/ height 2))

       h-delta (/ height iterations)
       h-strip-width (/ height iterations)
       half-h-strip-width (/ h-strip-width 2)

       v-delta (/ width iterations)
       v-strip-width (/ width iterations)
       half-v-strip-width (/ v-strip-width 2)

       rng (prng/build min: -1 max: 1 seed: seed)

       half-alpha (/ (col/get-alpha colour: colour) 2)
       lab-colour (col/set-alpha colour: (col/convert format: LAB colour: colour)
                                 value: half-alpha))

     ; horizontal strips
     (loop (i to: iterations)
       (define 
         [rx1 ry1 rx2 ry2 rx3 ry3 rx4 ry4] (prng/take num: 8 from: rng)
         lightness (+ (col/get-lab-l colour: lab-colour)
                      (* colour-volatility (prng/take-1 from: rng)))
         current-colour (col/set-lab-l colour: lab-colour value: lightness))
       (bezier tessellation: 10
               line-width: (+ overlap h-strip-width)
               coords: [[(+ (+ (* rx1 vol) start-x)
                            (* 0 third-width))
                         (+ (+ (* i h-delta) (* ry1 vol) start-y)
                            half-h-strip-width)]

                        [(+ (+ (* rx2 vol) start-x)
                            (* 1 third-width))
                         (+ (+ (* i h-delta) (* ry2 vol) start-y)
                            half-h-strip-width)]

                        [(+ (+ (* rx3 vol) start-x)
                            (* 2 third-width))
                         (+ (+ (* i h-delta) (* ry3 vol) start-y)
                            half-h-strip-width)]

                        [(+ (+ (* rx4 vol) start-x)
                            (* 3 third-width))
                         (+ (+ (* i h-delta) (* ry4 vol) start-y)
                            half-h-strip-width)]]
               colour: current-colour))
     ; vertical strips
     (loop (i to: iterations)
       (define 
         [rx1 ry1 rx2 ry2 rx3 ry3 rx4 ry4] (prng/take num: 8 from: rng)
         lightness (+ (col/get-lab-l colour: lab-colour)
                      (* colour-volatility (prng/take-1 from: rng)))
         current-colour (col/set-lab-l colour: lab-colour value: lightness))
       (bezier tessellation: 10
               line-width: (+ overlap v-strip-width)
               coords: [[(+ (+ (* i v-delta) (* rx1 vol) start-x)
                            half-v-strip-width)
                         (+ (+ (* ry1 vol) start-y)
                            (* 0 third-height))]

                        [(+ (+ (* i v-delta) (* rx2 vol) start-x)
                            half-v-strip-width)
                         (+ (+ (* ry2 vol) start-y)
                            (* 1 third-height))]

                        [(+ (+ (* i v-delta) (* rx3 vol) start-x)
                            half-v-strip-width)
                         (+ (+ (* ry3 vol) start-y)
                            (* 2 third-height))]

                        [(+ (+ (* i v-delta) (* rx4 vol) start-x)
                            half-v-strip-width)
                         (+ (+ (* ry4 vol) start-y)
                            (* 3 third-height))]]
               colour: current-colour)))

 (fn (wash variation: 200
           line-width: 70
           line-segments: 5
           colour: (col/rgb r: 0.627 g: 0.627 b: 0.627 alpha: 0.4)
           seed: 272)
     (define 
       w/3 (/ canvas/width 3)
       h/3 (/ canvas/height 3))
     (loop (h from: -20 to: 1020 increment: 20)
           (bezier tessellation: line-segments
                   line-width: line-width
                   coords: [[0 (wash-wobble x: 0 y: h z: seed s: variation)]
                            [w/3 (wash-wobble x: w/3 y: h z: seed s: variation)]
                            [(* w/3 2) (wash-wobble x: (* w/3 2) y: h z: seed s: variation)]
                            [canvas/width (wash-wobble x: canvas/width y: h z: seed s: variation)]]
                   colour: colour)

           (bezier tessellation: line-segments
                   line-width: line-width
                   coords: [[(wash-wobble x: 0 y: h z: seed s: variation) 0]
                            [(wash-wobble x: h/3 y: h z: seed s: variation) h/3]
                            [(wash-wobble x: (* h/3 2) y: h z: seed s: variation) (* h/3 2)]
                            [(wash-wobble x: canvas/height y: h z: seed s: variation) canvas/height]]
                   colour: colour)))

 (fn (wash-wobble x: 0 y: 0 z: 0 s: 1)
     (+ y (* s (prng/perlin x: x y: y z: z))))


* compiling function calls - TODO write up about implementation

  the CALL and CALL_0 are compiled with their offsets as bytcode args. this limits them to only being used where function calls are known at compile time.
  if CALL and CALL_0 got their offsets from the stack we could use them for calling functions that are not known until run-time


  (fn (j (z: 0)
      (+ z z)))

  (address-of j)  <- would this be a special form in the compiler?

  (define aj (address-of j))
  (fn-call (aj z: 44))   <- this is definitely a special form
  
  has to be since something like:
  (fn-call fn: aj z: 44)  
  couldn't be used in case the called function accepts a parameter named 'fn'

  ----------------------------------------------------------------------

  make fn_info array available to the vm
  can then invoke a function by using it's iname and the addresses required by CALL and CALL_0 can be looked up in the fn_info

  this will be required by map anyway

  (define some-vector [1 2 3 4 5 6])
  (fn (shabba a: 0) 
      (+ a a))
  (map a: some-vector fn: shabba)

  compiler should loop through the some-vector
  PUSH the iname of the function to call
  INVOKE: a special variation of CALL that looks up an iname in fn_info

  (fn-call @shabba)
  
  @ syntax mean 'address of' ie return the iname

  --------------------------------------------------

  implementation:

  address-of : works at compile time to LOAD the seni_fn_info index onto the stack. This means that address-of can only work with user-defined functions that are explicitly passed in.

* setup/teardown

one time init

  per-script init (includes allocations for render data)
    *run the compiled script*
  per-script shutdown <- (on success) clean up as much of the script state as possible

  *get render data from c-side to js-side* <- done by js-side when it wants to

  per-script cleanup <- invoked by js-side, cleans up all run data including render-data allocations

one time shutdown






* native functions that accept function arguments [0/2]

  1. [ ] create a dummy native function that accepts a 'draw' argument
  2. [ ] it's bind.c impl will invoke a function with the behaviour given below

  will need a vm_interpret like function that does the following:

  - create a stack frame
  - push an IP that is the current program's STOP instruction
  - invoke vm_interpret so that it starts at the function's CALL_0 location
  - once it's done it will RET and end up at the STOP

  this will all happen 'inside' a NATIVE call from the real vm_interpret


  --------------------------------------------------
     

  (repeat/symmetry-vertical draw: (address-of some-fn))

// invoke a function that has no arguments
// quite hacky but it will do for the repeat/* functions
call_no_arg_function



