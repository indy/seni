* TODO [0/5]
  1. [ ] evaluate any top-level defines and fns
  2. [ ] special fn: on-matrix-stack
  3. [ ] why does setq seg fault when it returns NULL?
  4. [ ] 'in' paramaeter for loop ?
  5. [ ] constants like canvas/width



after parsing it's safe to treat seni_nodes as immutable
seni_vars that have been eval'd should get their values asap since they could just by aliases of g_reg

* vector
bind a linked list of seni_var* to a variable in the current env scope

have checks when popping a scope to look for linked lists and manually de-allocate them (or return them to a pool of seni_var*. IMPORTANT: remember to iterate through each seni_var since there could be nested vectors)

how to know when to release the seni_vars?


easy to release vectors that are bound with define
(define a [1 2 3])

just clean up when the env is popped


might need a special case in the function application code when literal vectors are given
(do-something a: [1 2 3])


but the hardest is when a function returns a vector that's passed into another function
(do-something a: (make-vec len: 3))

perhaps assign the results of all functions to temporary variables which are in the current scope?

(do-something a: (define ##make-vec-len (make-vec len: 3)))

or special case if an argument is a function call and the return type is vector?



special case if an argument is a literal vector or a function call with a vector return type


* loop usage
from to
to
from to increment
from upto
from upto steps

* bytecode vm design for guile
  https://www.gnu.org/software/guile/manual/html_node/Why-a-VM_003f.html#Why-a-VM_003f

  bytecode interpreter written in C



Compiled code is run by a virtual machine (VM). Each thread has its own VM. The virtual machine executes the sequence of instructions in a procedure.

Each VM instruction starts by indicating which operation it is, and then follows by encoding its source and destination operands. Each procedure declares that it has some number of local variables, including the function arguments. These local variables form the available operands of the procedure, and are accessed by index.

The local variables for a procedure are stored on a stack. Calling a procedure typically enlarges the stack, and returning from a procedure shrinks it. Stack memory is exclusive to the virtual machine that owns it.

In addition to their stacks, virtual machines also have access to the global memory (modules, global bindings, etc) that is shared among other parts of Guile, including other VMs.

The registers that a VM has are as follows:

ip - Instruction pointer
sp - Stack pointer
fp - Frame pointer
In other architectures, the instruction pointer is sometimes called the "program counter" (pc). This set of registers is pretty typical for virtual machines; their exact meanings in the context of Guile's VM are described in the next section.



  

* simple bytecode vm
  https://www.youtube.com/watch?v=8k5h-A7JaaE&t=6s&index=36&list=WL
  1:03:39

  a lot of the enums start at 128

  opcode_t
  push add sub mul div mod neg ret

  char bytecode_buffer[1024];
  char *bytecode = bytecode_buffer;

  emit(uint8 byte) {
    *bytecode++ = byte;
  }
  emit4(uint32 data) {
    *(uint32 *)bytecode = data;
    bytecode += 4;
  }

  ---------------------------------------------------------------------------

  bytecode interpreter

  char *ip;
  int execute_stack[1024];
  int *sp = execute_stack

  void execute() {
    for(;;) {
      int op = *ip++;
      switch (op) {
      PUSH:
        *sp++ = *(uint32 *)ip;
        ip += 4;
      ADD:
        sp[-2] += sp[-1];
        sp--;
        break;
        ....
      RET:
        // return whats on top of the stack
        return sp[-1];
      }
 
    }
  }


  test code:

  emit(PUSH)
  emit(1)
  emit(PUSH)
  emit(2)
  emit(ADD)
  emit(RET)


  char emit_buffer[1024];
  emit_pointer = emit_buffer;

  int frame[1024];
  int stack[1024];

  ip = emit_buffer;
  fp = frame;
  sp = stack

  int val = execute();




* vm links
  https://github.com/munificent/wren
  http://wren.io/getting-started.html
  http://gameprogrammingpatterns.com/bytecode.html
  https://github.com/skx/simple.vm/tree/master/examples
  http://www.jucs.org/jucs_11_7/the_implementation_of_lua/jucs_11_7_1159_1176_defigueiredo.html
  http://smalltalk.gnu.org/files/vmspec.pdf
  http://stackoverflow.com/questions/20313122/generating-register-based-bytecode-from-an-abstract-syntax-tree
  http://hhvm.com/blog/6323/the-journey-of-a-thousand-bytecodes
  https://www.reddit.com/r/learnprogramming/comments/w6i0p/bytecode_execution_vs_ast_walking_speed/

* wren vm notes
  Unlike expressions, statements do not leave a value on the stack.


  wren_vm.c:
  initvm
    wrenconfiguration structure
    vm = wrenNewVM(configuration)
      symbol table init
      wrenInitializeCore                <<<-- wren_core.c
        define root Object class
        PRIMITIVE macro ?
        all the core primitives (keywords in seni?) have now been defined

  WrenInterpretResult result = wrenInterpret(vm, source); <<<-- vm.c
    WrenVM is passed around
    creates a 'main' module (in a tempRoot), creates a 'fiber' and runs interpreter with that fiber
      Value ???
      wrenStringFormat returns a large number
  is interpreter called twice? first for core module then for the user specified main module?
  loadModule calls wrenCompile
  
  wrenCompile <<<<-- wren_compiler.c
    lexer parser etc
    

  static WrenInterpretResult runInterpreter(WrenVM* vm, register ObjFiber* fiber) <<<<<-- wren_vm.c

  definition(compiler)
  statement(compiler)
  expression(compiler)
  literal(compiler, canAssign)
  emitConstant

  WREN_NAN_TAGGING - if not defined this makes debugging easier as Value has a type and num structure


* wren analysis scratch notes
>	wren_d.exe!emitOp(sCompiler * compiler, Code instruction) Line 1171	C
 	wren_d.exe!emitShortArg(sCompiler * compiler, Code instruction, int arg) Line 1200	C
 	wren_d.exe!emitConstant(sCompiler * compiler, unsigned __int64 value) Line 1221	C
 	wren_d.exe!literal(sCompiler * compiler, bool canAssign) Line 2267	C
 	wren_d.exe!parsePrecedence(sCompiler * compiler, Precedence precedence) Line 2680	C
 	wren_d.exe!infixOp(sCompiler * compiler, bool canAssign) Line 2434	C
 	wren_d.exe!parsePrecedence(sCompiler * compiler, Precedence precedence) Line 2686	C
 	wren_d.exe!expression(sCompiler * compiler) Line 2694	C
 	wren_d.exe!forStatement(sCompiler * compiler) Line 2905	C
 	wren_d.exe!statement(sCompiler * compiler) Line 2992	C
 	wren_d.exe!definition(sCompiler * compiler) Line 3421	C
 	wren_d.exe!wrenCompile(WrenVM * vm, ObjModule * module, const char * source, bool isExpression, bool printErrors) Line 3468	C
 	wren_d.exe!loadModule(WrenVM * vm, unsigned __int64 name, const char * source) Line 490	C
 	wren_d.exe!wrenInterpretInModule(WrenVM * vm, const char * module, const char * source) Line 1328	C
 	wren_d.exe!wrenInterpret(WrenVM * vm, const char * source) Line 1315	C
 	wren_d.exe!runFile(const char * path) Line 232	C






  when compiling user code set a breakpoint on emitOp wren_compiler.c 1170

  System.print("hello from isg")
  for (i in 1..10) System.print("Counting up %(i)")

  instruction	CODE_LOAD_MODULE_VAR (17)	Code
  instruction	CODE_CONSTANT (0)	Code
	instruction	CODE_CALL_1 (25)	Code
	instruction	CODE_POP (23)	Code
	instruction	CODE_CONSTANT (0)	Code
	instruction	CODE_CONSTANT (0)	Code
	instruction	CODE_CALL_1 (25)	Code
	instruction	CODE_NULL (1)	Code
	instruction	CODE_LOAD_LOCAL_0 (4)	Code
	instruction	CODE_LOAD_LOCAL_1 (5)	Code
	instruction	CODE_CALL_1 (25)	Code
	instruction	CODE_STORE_LOCAL (14)	Code
	instruction	CODE_JUMP_IF (60)	Code
	instruction	CODE_LOAD_LOCAL_0 (4)	Code
	instruction	CODE_LOAD_LOCAL_1 (5)	Code
	instruction	CODE_CALL_1 (25)	Code
	instruction	CODE_LOAD_MODULE_VAR (17)	Code
	instruction	CODE_LOAD_MODULE_VAR (17)	Code
	instruction	CODE_CALL_0 (24)	Code
	instruction	CODE_CONSTANT (0)	Code
	instruction	CODE_CALL_1 (25)	Code
	instruction	CODE_LOAD_LOCAL_2 (6)	Code
	instruction	CODE_CALL_1 (25)	Code
	instruction	CODE_CONSTANT (0)	Code
	instruction	CODE_CALL_1 (25)	Code
	instruction	CODE_CALL_0 (24)	Code
	instruction	CODE_CALL_1 (25)	Code
	instruction	CODE_POP (23)	Code
	instruction	CODE_LOOP (59)	Code




* wren build shenanigans

Build Events -> Command Line had the following pasted in:

python ../../libuv.py download
python ../../libuv.py build -32
